#include <Servo.h>

Servo steering;
int servoPin = 9;

int RPWM = 5;
int LPWM = 6;

int L_EN = 7;
int R_EN = 8;

// Timeout parameters
const unsigned long TIMEOUT_MS = 500; // Stop if no data for 0.5 seconds
unsigned long lastSignalTime = 0;

void setup() {
  Serial.begin(115200);
  steering.attach(servoPin);

  for (int i = 5; i < 9; i++) {
    pinMode(i, OUTPUT);
    digitalWrite(i, LOW); // Start low
  }

  // Enable H-Bridge
  digitalWrite(R_EN, HIGH);
  digitalWrite(L_EN, HIGH);

  Serial.println("READY");
  lastSignalTime = millis();
}

void loop() {
  // 1. SAFETY CHECK: Has it been too long since we heard from Python?
  if (millis() - lastSignalTime > TIMEOUT_MS) {
     stopMotors();
  }

  // 2. READ DATA: Only run if data is waiting
  if (Serial.available() > 0) {
    // Reset the safety timer
    lastSignalTime = millis();

    // Read integers directly (Faster than String)
    // Expecting: "300,32\n" (Angle*10, Speed)
    int raw_angle = Serial.parseInt();
    int speed = Serial.parseInt();

    // Clear the buffer (read until newline)
    if (Serial.read() == '\n') {

      // --- STEERING ---
      // Python sends angle * 10 (e.g., -300 to 300)
      // Map -300/300 directly to servo 60/120
      int servo_val = map(raw_angle, -300, 300, 60, 120);
      steering.write(servo_val);

      // --- MOTOR CONTROL ---
      // Logic for Forward, Reverse, and Stop
      if (speed > 0) {
        analogWrite(LPWM, 0);
        analogWrite(RPWM, speed);
      }
      else if (speed < 0) {
        analogWrite(RPWM, 0);
        analogWrite(LPWM, abs(speed)); // PWM must be positive
      }
      else {
        stopMotors();
      }
    }
  }
}

void stopMotors() {
  analogWrite(RPWM, 0);
  analogWrite(LPWM, 0);
}